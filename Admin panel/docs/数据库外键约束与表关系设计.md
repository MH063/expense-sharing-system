# 数据库外键约束与表关系设计

## 1. 表结构定义

### 1.1 核心表结构

```sql
// 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    role VARCHAR(20) DEFAULT '普通用户', -- 角色：系统管理员, 管理员, 寝室长, 缴费人, 普通用户
    room_id UUID REFERENCES rooms(id) ON DELETE SET NULL ON UPDATE CASCADE, -- 用户所属寝室ID，用于数据隔离
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加角色约束，确保角色值有效
    CONSTRAINT check_role_valid CHECK (role IN ('系统管理员', '管理员', '寝室长', '缴费人', '普通用户'))
);

// 寝室表
CREATE TABLE rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    creator_id UUID REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE, -- 寝室创建者ID
    created_at TIMESTAMP DEFAULT NOW()
);

// 费用表
CREATE TABLE expenses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    amount DECIMAL(10,2) NOT NULL,
    category VARCHAR(50) NOT NULL,
    description TEXT,
    payer_id UUID REFERENCES users(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    room_id UUID REFERENCES rooms(id) ON DELETE RESTRICT ON UPDATE CASCADE, -- 费用所属寝室ID，关键数据隔离字段
    split_algorithm VARCHAR(20) DEFAULT 'equal', -- 智能分摊算法类型
    split_parameters JSONB, -- 分摊算法参数
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保费用记录只能属于用户所在寝室
    CONSTRAINT check_user_room_match CHECK (
        EXISTS (
            SELECT 1 FROM users u WHERE u.id = payer_id AND u.room_id = room_id
        )
    )
);

// 智能分摊规则表
CREATE TABLE split_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID REFERENCES rooms(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 规则所属寝室ID，关键数据隔离字段
    category VARCHAR(50) NOT NULL,
    algorithm VARCHAR(20) NOT NULL,
    parameters JSONB,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

// 用户寝室关联表（支持用户可能属于多个寝室的场景）
CREATE TABLE user_room_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    room_id UUID REFERENCES rooms(id) ON DELETE CASCADE ON UPDATE CASCADE,
    relation_type VARCHAR(20) NOT NULL, -- 关系类型：owner, member, payer等
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, room_id) -- 确保用户在同一寝室只有一条记录
);

// 费用分摊明细表（记录每个费用在成员间的分摊详情）
CREATE TABLE expense_splits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    expense_id UUID REFERENCES expenses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    amount DECIMAL(10,2) NOT NULL, -- 该用户需承担的金额
    split_type VARCHAR(20) NOT NULL, -- 分摊类型：equal, custom, by_days等
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保分摊记录只能属于费用所在寝室的成员
    CONSTRAINT check_split_user_in_room CHECK (
        EXISTS (
            SELECT 1 FROM expenses e 
            JOIN user_room_relations urr ON e.room_id = urr.room_id 
            WHERE e.id = expense_id AND urr.user_id = user_id AND urr.is_active = TRUE
        )
    )
);

// 账单表
CREATE TABLE bills (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID REFERENCES rooms(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 账单所属寝室ID，关键数据隔离字段
    title VARCHAR(200) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    due_date DATE,
    status VARCHAR(20) DEFAULT 'pending', -- pending, paid, overdue
    creator_id UUID REFERENCES users(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保账单只能由本寝室用户创建
    CONSTRAINT check_bill_creator_in_room CHECK (
        EXISTS (
            SELECT 1 FROM user_room_relations urr 
            WHERE urr.room_id = room_id AND urr.user_id = creator_id AND urr.is_active = TRUE
        )
    )
);

// 支付记录表
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bill_id UUID REFERENCES bills(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    amount DECIMAL(10,2) NOT NULL,
    payment_method VARCHAR(50),
    payment_time TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending', -- pending, completed, failed
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保支付记录只能属于账单所在寝室的成员
    CONSTRAINT check_payment_user_in_room CHECK (
        EXISTS (
            SELECT 1 FROM bills b 
            JOIN user_room_relations urr ON b.room_id = urr.room_id 
            WHERE b.id = bill_id AND urr.user_id = user_id AND urr.is_active = TRUE
        )
    )
);
```

### 1.2 审计相关表结构

```sql
// 审计日志表
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    operation_type VARCHAR(50) NOT NULL, -- 操作类型：create, update, delete, login, logout等
    resource_type VARCHAR(50) NOT NULL, -- 资源类型：expense, user, room, system_config等
    resource_id UUID, -- 被操作的资源ID
    operation_details JSONB, -- 操作详细信息，包括修改前后的数据对比
    ip_address INET, -- 操作者IP地址
    user_agent TEXT, -- 用户代理信息
    operation_time TIMESTAMP DEFAULT NOW(), -- 操作时间
    created_at TIMESTAMP DEFAULT NOW()
);

// 费用操作审计表（专门记录费用相关操作的详细信息）
CREATE TABLE expense_audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    audit_log_id UUID REFERENCES audit_logs(id) ON DELETE CASCADE ON UPDATE CASCADE,
    expense_id UUID REFERENCES expenses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    operation_type VARCHAR(20) NOT NULL, -- create, update, delete
    old_amount DECIMAL(10,2), -- 修改前的金额
    new_amount DECIMAL(10,2), -- 修改后的金额
    old_category VARCHAR(50), -- 修改前的类别
    new_category VARCHAR(50), -- 修改后的类别
    old_description TEXT, -- 修改前的描述
    new_description TEXT, -- 修改后的描述
    old_split_algorithm VARCHAR(20), -- 修改前的分摊算法
    new_split_algorithm VARCHAR(20), -- 修改后的分摊算法
    old_split_parameters JSONB, -- 修改前的分摊参数
    new_split_parameters JSONB, -- 修改后的分摊参数
    operation_reason TEXT, -- 操作原因
    created_at TIMESTAMP DEFAULT NOW()
);

// 登录安全审计表（专门记录登录相关操作）
CREATE TABLE login_audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    audit_log_id UUID REFERENCES audit_logs(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE,
    login_type VARCHAR(20) NOT NULL, -- login, logout, failed_login, password_change等
    success BOOLEAN NOT NULL, -- 是否成功
    failure_reason VARCHAR(100), -- 失败原因
    ip_address INET, -- IP地址
    device_info JSONB, -- 设备信息
    location VARCHAR(100), -- 地理位置
    is_suspicious BOOLEAN DEFAULT FALSE, -- 是否为可疑操作
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 1.3 审核相关表结构

```sql
// 费用审核表（支持多级审核机制）
CREATE TABLE expense_reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    expense_id UUID NOT NULL REFERENCES expenses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    submitted_by UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT ON UPDATE CASCADE, -- 提交审核的用户
    reason TEXT, -- 提交审核的原因
    current_level VARCHAR(20) NOT NULL, -- 当前审核级别：寝室长, 缴费人, 系统自动审核
    status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 审核状态：pending, approved, rejected, escalated
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

// 审核链记录表（记录每一级审核的详细信息）
CREATE TABLE review_chain_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES expense_reviews(id) ON DELETE CASCADE ON UPDATE CASCADE,
    level VARCHAR(20) NOT NULL, -- 审核级别：寝室长, 缴费人, 系统自动审核
    reviewer_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT ON UPDATE CASCADE, -- 审核人ID
    reviewer_name VARCHAR(100) NOT NULL, -- 审核人姓名（冗余存储，便于查询）
    decision VARCHAR(20) NOT NULL, -- 审核决定：approved, rejected, escalated
    comments TEXT, -- 审核意见
    reviewed_at TIMESTAMP DEFAULT NOW(), -- 审核时间
    -- 添加数据隔离约束：确保审核人只能审核其权限范围内的费用
    CONSTRAINT check_reviewer_permission CHECK (
        -- 寝室长只能审核本寝室的费用
        (level = '寝室长' AND EXISTS (
            SELECT 1 FROM expenses e 
            JOIN users u ON e.room_id = u.room_id 
            WHERE e.id = review_id AND u.id = reviewer_id AND u.role = '寝室长'
        )) OR
        -- 缴费人可以审核费用，并具有最高的审核权限，可以直接进行审核
        (level = '缴费人' AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = reviewer_id AND u.role = '缴费人'
        )) OR
        -- 系统自动审核
        (level = '系统自动审核')
    )
);

// 审核通知表（记录审核相关的通知）
CREATE TABLE review_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES expense_reviews(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 接收通知的用户
    notification_type VARCHAR(50) NOT NULL, -- 通知类型：submitted, processing, completed
    title VARCHAR(200) NOT NULL, -- 通知标题
    content TEXT, -- 通知内容
    is_read BOOLEAN DEFAULT FALSE, -- 是否已读
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 1.4 争议处理相关表结构

```sql
// 费用争议表（记录费用相关的争议）
CREATE TABLE expense_disputes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    expense_id UUID NOT NULL REFERENCES expenses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    submitter_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 提交争议的用户
    dispute_type VARCHAR(20) NOT NULL, -- 争议类型：amount, split, attribution, period
    description TEXT NOT NULL, -- 争议描述
    status VARCHAR(20) DEFAULT 'pending', -- 争议状态：pending, processing, resolved, escalated
    level VARCHAR(20) DEFAULT 'room', -- 争议级别：room（寝室级）, system（系统级）
    escalation_reason TEXT, -- 升级原因
    created_at TIMESTAMP DEFAULT NOW(),
    resolved_at TIMESTAMP, -- 解决时间
    -- 添加数据隔离约束：确保只有费用所在寝室的成员可以提交争议
    CONSTRAINT check_dispute_submitter_in_room CHECK (
        EXISTS (
            SELECT 1 FROM expenses e 
            JOIN user_room_relations urr ON e.room_id = urr.room_id 
            WHERE e.id = expense_id AND urr.user_id = submitter_id AND urr.is_active = TRUE
        )
    )
);

// 争议协商记录表（记录争议协商过程）
CREATE TABLE dispute_negotiations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    dispute_id UUID NOT NULL REFERENCES expense_disputes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    participant_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 参与协商的用户
    message TEXT NOT NULL, -- 协商消息
    created_at TIMESTAMP DEFAULT NOW()
);

// 争议处理记录表（记录争议处理过程）
CREATE TABLE dispute_resolutions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    dispute_id UUID NOT NULL REFERENCES expense_disputes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    processor_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT ON UPDATE CASCADE, -- 处理人ID
    processor_name VARCHAR(100) NOT NULL, -- 处理人姓名（冗余存储，便于查询）
    processor_role VARCHAR(20) NOT NULL, -- 处理人角色：寝室长, 管理员
    action VARCHAR(50) NOT NULL, -- 处理动作：investigate, negotiate, resolve, escalate
    action_details JSONB, -- 处理动作详细信息
    notes TEXT, -- 处理备注
    next_step VARCHAR(100), -- 下一步行动
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保处理人有权限处理争议
    CONSTRAINT check_dispute_processor_permission CHECK (
        -- 寝室长只能处理本寝室的争议
        (processor_role = '寝室长' AND EXISTS (
            SELECT 1 FROM expense_disputes ed
            JOIN expenses e ON ed.expense_id = e.id
            JOIN users u ON e.room_id = u.room_id 
            WHERE ed.id = dispute_id AND u.id = processor_id AND u.role = '寝室长'
        )) OR
        -- 管理员可以处理系统内的争议
        (processor_role = '管理员' AND EXISTS (
            SELECT 1 FROM users u WHERE u.id = processor_id AND u.role = '管理员'
        ))
    )
);

// 争议通知表（记录争议相关的通知）
CREATE TABLE dispute_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    dispute_id UUID NOT NULL REFERENCES expense_disputes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 接收通知的用户
    notification_type VARCHAR(50) NOT NULL, -- 通知类型：submitted, processing, resolved, escalated
    title VARCHAR(200) NOT NULL, -- 通知标题
    content TEXT, -- 通知内容
    is_read BOOLEAN DEFAULT FALSE, -- 是否已读
    created_at TIMESTAMP DEFAULT NOW()
);

// 争议证据表（存储争议相关的证据文件）
CREATE TABLE dispute_evidence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    dispute_id UUID NOT NULL REFERENCES expense_disputes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    uploaded_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 上传证据的用户
    file_name VARCHAR(255) NOT NULL, -- 文件名
    file_path VARCHAR(500) NOT NULL, -- 文件存储路径
    file_type VARCHAR(50) NOT NULL, -- 文件类型：image, document, video, audio
    file_size INTEGER, -- 文件大小（字节）
    description TEXT, -- 文件描述
    is_valid BOOLEAN DEFAULT TRUE, -- 是否有效证据
    validated_by UUID REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE, -- 验证证据的用户
    validated_at TIMESTAMP, -- 验证时间
    created_at TIMESTAMP DEFAULT NOW(),
    -- 添加数据隔离约束：确保只有费用所在寝室的成员可以上传证据
    CONSTRAINT check_evidence_user_in_room CHECK (
        EXISTS (
            SELECT 1 FROM expense_disputes ed
            JOIN expenses e ON ed.expense_id = e.id
            JOIN user_room_relations urr ON e.room_id = urr.room_id 
            WHERE ed.id = dispute_id AND urr.user_id = uploaded_by AND urr.is_active = TRUE
        )
    )
);

// WebSocket连接表（记录用户WebSocket连接信息）
CREATE TABLE websocket_connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- 关联用户
    connection_id VARCHAR(100) NOT NULL UNIQUE, -- WebSocket连接ID
    client_id VARCHAR(100), -- 客户端标识
    ip_address INET, -- 客户端IP地址
    user_agent TEXT, -- 用户代理信息
    connected_at TIMESTAMP DEFAULT NOW(), -- 连接时间
    disconnected_at TIMESTAMP, -- 断开时间
    is_active BOOLEAN DEFAULT TRUE, -- 是否活跃连接
    subscriptions JSONB, -- 订阅的事件类型
    created_at TIMESTAMP DEFAULT NOW()
);
```

## 2. 表关系图

### 2.1 核心业务表关系

```
[users] 1--* [user_room_relations] *--1 [rooms]
   |                                    |
   | 1--*                                | 1--*
   |                                    |
   v                                    v
[expenses] 1--* [expense_splits] *--1 [users]
   |                                    |
   | 1--*                                | 1--*
   |                                    |
   v                                    v
[bills] 1--* [payments] *--1 [users]
   |
   | 1--*
   |
   v
[split_rules]
```

### 2.2 审核流程表关系

```
[expenses] 1--1 [expense_reviews] 1--* [review_chain_records]
               |                            |
               | 1--*                        | *--1
               |                            |
               v                            v
        [review_notifications] <------- [users]
               ^
               |
               | 1--*
               |
        [review_configurations]
```

### 2.3 争议处理表关系

```
[expenses] 1--* [expense_disputes] 1--* [dispute_negotiations]
                                     |           |
                                     | 1--*       | *--1
                                     |           |
                                     v           v
                              [dispute_evidence] <--- [users]
                                     |
                                     | 1--*
                                     |
                              [dispute_resolutions]
                                     |
                                     | 1--*
                                     |
                              [dispute_notifications]
```

### 2.4 审计日志表关系

```
[users] 1--* [audit_logs] 1--* [expense_audit_logs] *--1 [expenses]
   |                            |
   | 1--*                        | 1--*
   |                            |
   v                            v
[login_audit_logs] <------- [users]
```

### 2.5 WebSocket连接表关系

```
[users] 1--* [websocket_connections]
```

## 3. 外键约束策略说明

### 3.1 删除策略 (ON DELETE)

- **CASCADE**: 级联删除，当主表记录被删除时，从表相关记录也被删除
  - 适用于强依赖关系，如费用分摊记录依赖于费用记录
  - 使用场景：expense_splits -> expenses, user_room_relations -> users/rooms

- **RESTRICT**: 限制删除，当从表存在相关记录时，禁止删除主表记录
  - 适用于需要保护数据完整性的场景
  - 使用场景：expenses -> users/rooms, payments -> bills

- **SET NULL**: 设置为空，当主表记录被删除时，从表相关记录外键字段设为NULL
  - 适用于可选关系，如用户可以不属于任何寝室
  - 使用场景：users.room_id, rooms.creator_id

### 3.2 更新策略 (ON UPDATE)

- **CASCADE**: 级联更新，当主表主键更新时，从表相关记录外键也更新
  - 适用于大多数场景，特别是使用UUID作为主键的情况
  - 所有外键约束都使用CASCADE更新策略

### 3.3 数据完整性保障

1. **引用完整性**：
   - 所有外键约束确保从表记录引用的主表记录必须存在
   - 防止孤立记录的产生

2. **业务规则完整性**：
   - 通过CHECK约束确保数据符合业务规则
   - 如用户角色必须在预定义范围内

3. **数据一致性**：
   - 通过事务确保相关操作的原子性
   - 避免部分更新导致的数据不一致

## 4. 表关系详细说明

### 4.1 用户与寝室关系

- **多对多关系**：用户可以属于多个寝室，寝室可以有多个用户
- **中间表**：user_room_relations表维护多对多关系
- **关系类型**：通过relation_type字段区分用户在寝室中的角色

### 4.2 费用与分摊关系

- **一对多关系**：一个费用可以有多个分摊记录
- **分摊对象**：每个分摊记录关联一个用户
- **分摊类型**：通过split_type字段区分分摊方式

### 4.3 审核流程关系

- **链式审核**：一个费用审核可以有多个审核环节
- **审核级别**：通过level字段区分审核级别
- **审核权限**：通过CHECK约束确保审核人有权限审核对应费用

### 4.4 争议处理关系

- **争议关联**：一个费用可以有多个争议

### 4.5 WebSocket连接关系

- **用户连接**：一个用户可以有多个WebSocket连接（多设备支持）
- **连接管理**：通过连接ID唯一标识每个WebSocket连接
- **订阅管理**：记录每个连接订阅的事件类型

## 5. 数据访问权限控制

### 5.1 角色权限定义

系统设置五种用户角色，每种角色具有不同的数据访问权限：

1. **系统管理员**：
   - 系统内置角色用户，信息不可修改
   - 仅具备系统维护相关权限：
     - 系统配置管理
     - 系统运行状态监控
     - 系统更新与升级
     - 系统日志查看与管理
     - 系统性能监控
   - 严格禁止接触任何真实业务数据和用户个人信息：
     - 不得查看、编辑、删除任何用户的个人敏感信息（如姓名、联系方式、身份证号等）
     - 不得访问具体的费用记录、账单详情、支付记录等业务数据
     - 不得参与任何与用户数据直接相关的业务操作
   - 只能访问经过脱敏处理的统计数据和系统管理信息

2. **管理员**：
   - 负责权限的下发和用户管理
   - 可以查看和管理所有用户权限相关数据
   - 可以查看系统统计数据和运行报表
   - 不能查看具体用户的个人敏感信息（如身份证号、联系方式等）

3. **寝室长**：
   - 负责管理本寝室的费用和成员
   - 可以查看和管理本寝室的所有费用数据
   - 可以审核本寝室的费用记录
   - 可以处理本寝室的争议

4. **缴费人**：
   - 只与费用相关的权限有关，该权限只有该角色特有
   - 可以参与费用审核流程
   - 可以查看与自己相关的费用信息
   - 可以添加、编辑、删除本寝室的费用记录

5. **普通用户**：
   - 系统的基本使用者
   - 只能查看和管理自己的数据
   - 可以提交费用记录
   - 可以查看自己的账单和支付记录

### 5.2 数据隔离机制

为确保用户隐私和数据安全，系统实施严格的数据访问权限控制：

1. **系统管理员数据访问限制**：
   - 系统管理员作为系统内置角色用户，其信息不可修改
   - 系统管理员仅具备系统维护相关权限：
     - 系统配置管理
     - 系统运行状态监控
     - 系统更新与升级
     - 系统日志查看与管理
     - 系统性能监控
   - 系统管理员严格禁止接触任何真实业务数据和用户个人信息：
     - 不得查看、编辑、删除任何用户的个人敏感信息（如姓名、联系方式、身份证号等）
     - 不得访问具体的费用记录、账单详情、支付记录等业务数据
     - 不得参与任何与用户数据直接相关的业务操作
   - 系统管理员只能访问经过脱敏处理的统计数据和系统管理信息

2. **数据脱敏处理**：
   - 对于系统管理员可访问的统计数据，所有用户个人标识信息都将被脱敏处理
   - 脱敏方式包括：姓名用*号替代部分字符、联系方式部分隐藏、身份证号仅显示后四位等
   - 真实数据仅对具有相应权限的管理员、寝室长等角色开放

3. **审计日志**：
   - 所有数据访问操作都将被记录在审计日志中
   - 系统管理员的数据访问行为也将被监控和记录
   - 定期审查数据访问日志，确保权限控制的有效性

## 6. 数据库安全设计

### 6.1 数据库架构设计

为确保系统安全性和数据隔离，系统采用双数据库架构：

1. **生产数据库**：
   - 用于存储真实用户数据
   - 包含所有业务数据表
   - 实施严格的安全防护措施

2. **测试数据库**：
   - 仅用于系统测试
   - 表结构与生产数据库完全一致
   - 包含模拟测试数据

### 6.2 安全防护措施

1. **企业级安全标准**：
   - 数据库安全等级达到企业级别
   - 实施防信息泄露和被盗等安全保护机制
   - 定期进行安全漏洞扫描和修复

2. **访问控制**：
   - 基于角色的访问控制（RBAC）
   - 细粒度的数据访问权限管理
   - 严格的用户身份验证和授权机制

3. **数据加密**：
   - 敏感数据加密存储
   - 传输层加密（TLS/SSL）
   - 数据库连接加密

4. **审计与监控**：
   - 完整的操作日志记录
   - 实时安全监控
   - 异常行为检测和告警

5. **备份与恢复**：
   - 定期数据备份
   - 灾难恢复机制
   - 数据一致性保障

### 6.3 攻击防护机制

1. **SQL注入防护**：
   - 使用参数化查询
   - 输入验证和过滤
   - SQL语句预编译

2. **跨站脚本攻击（XSS）防护**：
   - 输出编码和转义
   - 内容安全策略（CSP）
   - 输入数据验证

3. **跨站请求伪造（CSRF）防护**：
   - CSRF令牌验证
   - SameSite Cookie属性
   - 请求来源验证

4. **拒绝服务攻击（DoS）防护**：
   - 请求频率限制
   - 资源配额管理
   - 负载均衡和自动扩展