# 技术架构更新文档

## 1. 数据库优化方案

### 1.1 分表分库迁移策略

#### 1.1.1 分表策略实施

**水平分表（按时间维度）：**
```sql
-- 费用表按月分表示例
CREATE TABLE expenses_202401 LIKE expenses;
CREATE TABLE expenses_202402 LIKE expenses;
-- 创建分表视图
CREATE VIEW expenses_all AS 
SELECT * FROM expenses_202401
UNION ALL SELECT * FROM expenses_202402
UNION ALL SELECT * FROM expenses_current;
```

**分表路由中间件：**
```javascript
// 分表路由器实现
class TableRouter {
  constructor() {
    this.tableConfigs = {
      expenses: {
        type: 'time',
        format: 'YYYYMM',
        currentTable: 'expenses_current'
      },
      review_records: {
        type: 'time', 
        format: 'YYYY[q]Q',
        currentTable: 'review_records_current'
      }
    };
  }
  
  routeTable(baseTable, conditions = {}) {
    const config = this.tableConfigs[baseTable];
    if (!config) return baseTable;
    
    if (config.type === 'time' && conditions.created_at) {
      const date = new Date(conditions.created_at);
      const tableSuffix = this.formatDate(date, config.format);
      return `${baseTable}_${tableSuffix}`;
    }
    
    return config.currentTable;
  }
}
```

#### 1.1.2 分库策略实施

**垂直分库架构：**
- **核心业务库**：存储用户、寝室、费用等核心数据
- **审核流程库**：存储审核记录、审核配置数据
- **争议处理库**：存储争议记录、协商过程数据
- **日志审计库**：存储操作日志、安全审计数据

**分库路由配置：**
```javascript
// 分库路由器
class DatabaseRouter {
  constructor() {
    this.dbConfigs = {
      core: {
        host: 'db-core.example.com',
        database: 'dorm_expense_core',
        tables: ['users', 'rooms', 'expenses', 'bills']
      },
      review: {
        host: 'db-review.example.com',
        database: 'dorm_expense_review',
        tables: ['expense_reviews', 'review_chain_records']
      }
    };
  }
  
  routeDatabase(tableName) {
    for (const [dbName, config] of Object.entries(this.dbConfigs)) {
      if (config.tables.includes(tableName)) {
        return config;
      }
    }
    return this.dbConfigs.core; // 默认返回核心库
  }
}
```

### 1.2 数据库迁移完成状态

#### 1.2.1 MySQL到PostgreSQL迁移已完成

**迁移优势：**
- PostgreSQL在JSON处理、地理空间数据、复杂查询方面更优
- 更好的并发性能和事务处理能力
- 更丰富的内置函数和扩展支持

**迁移状态：** ✅ 已完成
- **数据迁移工具：** 使用自定义迁移脚本完成
- **数据类型映射：**
   - MySQL INT → PostgreSQL INTEGER
   - MySQL VARCHAR → PostgreSQL VARCHAR
   - MySQL DATETIME → PostgreSQL TIMESTAMP
   - MySQL TEXT → PostgreSQL TEXT
- **迁移验证：** 数据一致性检查、性能对比测试已完成

**当前数据库架构：**
- **主数据库：** PostgreSQL 13+
- **缓存数据库：** Redis 6.0+
- **连接池配置：** 已优化完成

#### 1.2.2 读写分离中间件

```javascript
// 读写分离中间件
class ReadWriteSplitter {
  constructor() {
    this.writePool = new DatabasePool('write');
    this.readPool = new DatabasePool('read');
  }
  
  getConnection(sql, params) {
    const isReadOperation = this.isReadOperation(sql);
    return isReadOperation ? this.readPool.getConnection() : this.writePool.getConnection();
  }
  
  isReadOperation(sql) {
    const readKeywords = ['SELECT', 'SHOW', 'DESCRIBE'];
    const upperSql = sql.toUpperCase();
    return readKeywords.some(keyword => upperSql.startsWith(keyword));
  }
}
```

### 1.3 数据一致性保障

#### 1.3.1 分布式事务处理

**两阶段提交协议：**
```javascript
class DistributedTransaction {
  async execute(operations) {
    // 第一阶段：准备阶段
    const prepared = await Promise.all(
      operations.map(op => op.prepare())
    );
    
    // 第二阶段：提交阶段
    if (prepared.every(result => result.success)) {
      await Promise.all(operations.map(op => op.commit()));
    } else {
      await Promise.all(operations.map(op => op.rollback()));
    }
  }
}
```

#### 1.3.2 最终一致性方案

**基于消息队列的最终一致性：**
```javascript
class EventualConsistencyManager {
  async processOperation(operation) {
    // 1. 在主库执行操作
    const result = await this.executeOnMaster(operation);
    
    // 2. 发送同步消息到消息队列
    await this.publishSyncMessage({
      operation: operation.type,
      data: operation.data,
      timestamp: Date.now()
    });
    
    return result;
  }
  
  async syncFromQueue(message) {
    // 从消息队列消费并同步到从库
    await this.executeOnSlave(message);
  }
}
```

## 2. 缓存层设计

### 2.1 Redis缓存策略

#### 2.1.1 缓存键设计规范

```javascript
// 缓存键命名规范
const CacheKeys = {
  // 用户相关
  USER_PROFILE: (userId) => `user:profile:${userId}`,
  USER_ROOMS: (userId) => `user:rooms:${userId}`,
  
  // 寝室相关
  ROOM_INFO: (roomId) => `room:info:${roomId}`,
  ROOM_MEMBERS: (roomId) => `room:members:${roomId}`,
  
  // 费用相关
  EXPENSE_DETAIL: (expenseId) => `expense:detail:${expenseId}`,
  ROOM_EXPENSES: (roomId) => `room:expenses:${roomId}`,
  
  // 系统配置
  SYSTEM_CONFIG: (configKey) => `system:config:${configKey}`
};
```

#### 2.1.2 缓存失效策略

```javascript
class CacheManager {
  constructor() {
    this.defaultTTL = {
      userProfile: 3600, // 1小时
      roomInfo: 1800,   // 30分钟
      expenseDetail: 900, // 15分钟
      systemConfig: 86400 // 24小时
    };
  }
  
  async setWithTTL(key, value, ttlType) {
    const ttl = this.defaultTTL[ttlType] || 300;
    await redis.setex(key, ttl, JSON.stringify(value));
  }
  
  async getWithRefresh(key, ttlType, fetchFunc) {
    const cached = await redis.get(key);
    if (cached) {
      // 异步刷新缓存
      this.refreshCache(key, ttlType, fetchFunc);
      return JSON.parse(cached);
    }
    
    const data = await fetchFunc();
    await this.setWithTTL(key, data, ttlType);
    return data;
  }
}
```

### 2.2 分布式会话管理

#### 2.2.1 会话存储设计

```javascript
class SessionManager {
  constructor() {
    this.sessionPrefix = 'session:';
  }
  
  async createSession(userId, userData) {
    const sessionId = generateSessionId();
    const sessionData = {
      userId,
      ...userData,
      createdAt: Date.now(),
      lastAccessed: Date.now()
    };
    
    await redis.setex(
      `${this.sessionPrefix}${sessionId}`,
      7200, // 2小时
      JSON.stringify(sessionData)
    );
    
    return sessionId;
  }
  
  async validateSession(sessionId) {
    const sessionKey = `${this.sessionPrefix}${sessionId}`;
    const sessionData = await redis.get(sessionKey);
    
    if (sessionData) {
      // 更新最后访问时间
      const data = JSON.parse(sessionData);
      data.lastAccessed = Date.now();
      await redis.setex(sessionKey, 7200, JSON.stringify(data));
      
      return data;
    }
    
    return null;
  }
}
```

### 2.3 热点数据缓存

#### 2.3.1 热点数据识别

```javascript
class HotspotDetector {
  constructor() {
    this.accessCounts = new Map();
    this.hotspotThreshold = 100; // 访问阈值
  }
  
  recordAccess(key) {
    const count = this.accessCounts.get(key) || 0;
    this.accessCounts.set(key, count + 1);
    
    if (count + 1 >= this.hotspotThreshold) {
      this.markAsHotspot(key);
    }
  }
  
  markAsHotspot(key) {
    // 将热点数据加入特殊缓存池
    redis.sadd('hotspot:keys', key);
  }
}
```

#### 2.3.2 缓存预热策略

```javascript
class CacheWarmup {
  async warmupHotData() {
    // 预加载常用数据
    const warmupTasks = [
      this.warmupSystemConfigs(),
      this.warmupActiveUsers(),
      this.warmupRecentExpenses()
    ];
    
    await Promise.all(warmupTasks);
  }
  
  async warmupSystemConfigs() {
    const configs = await SystemConfig.findAll();
    for (const config of configs) {
      await redis.set(
        `system:config:${config.key}`,
        JSON.stringify(config.value)
      );
    }
  }
}
```

## 3. 消息队列设计

### 3.1 异步任务处理

#### 3.1.1 任务队列架构

```javascript
class TaskQueue {
  constructor() {
    this.queues = {
      'email': new Queue('email'),
      'notification': new Queue('notification'),
      'data-sync': new Queue('data-sync'),
      'export': new Queue('export')
    };
  }
  
  async enqueue(queueName, taskData, options = {}) {
    const queue = this.queues[queueName];
    if (!queue) throw new Error(`Queue ${queueName} not found`);
    
    return await queue.add(taskData, {
      delay: options.delay || 0,
      attempts: options.attempts || 3,
      backoff: options.backoff || 'exponential'
    });
  }
}
```

#### 3.1.2 任务处理器

```javascript
class TaskProcessor {
  constructor() {
    this.processors = {
      'send-email': this.processSendEmail,
      'push-notification': this.processPushNotification,
      'sync-data': this.processDataSync
    };
  }
  
  async process(job) {
    const processor = this.processors[job.name];
    if (!processor) {
      throw new Error(`No processor found for job: ${job.name}`);
    }
    
    try {
      await processor(job.data);
      await job.complete();
    } catch (error) {
      await job.fail(error);
    }
  }
  
  async processSendEmail(data) {
    const { to, subject, template, variables } = data;
    await emailService.send({
      to, subject, template, variables
    });
  }
}
```

### 3.2 通知消息队列

#### 3.2.1 实时通知推送

```javascript
class NotificationQueue {
  async pushNotification(userId, notification) {
    // 1. 存储到数据库
    const savedNotification = await Notification.create({
      userId,
      type: notification.type,
      title: notification.title,
      content: notification.content,
      isRead: false
    });
    
    // 2. 推送到消息队列
    await this.queues.notification.add({
      action: 'push',
      userId,
      notification: savedNotification
    });
    
    // 3. WebSocket实时推送
    await this.pushViaWebSocket(userId, savedNotification);
  }
  
  async pushViaWebSocket(userId, notification) {
    const socket = this.getUserSocket(userId);
    if (socket) {
      socket.emit('notification', notification);
    }
  }
}
```

### 3.3 数据同步队列

#### 3.3.1 跨库数据同步

```javascript
class DataSyncQueue {
  async syncUserData(userId, operation, data) {
    const syncTasks = [
      this.syncToAnalyticsDB(userId, operation, data),
      this.syncToAuditDB(userId, operation, data),
      this.syncToCache(userId, operation, data)
    ];
    
    await Promise.all(syncTasks);
  }
  
  async syncToAnalyticsDB(userId, operation, data) {
    await this.queues['data-sync'].add({
      target: 'analytics',
      operation,
      userId,
      data,
      timestamp: Date.now()
    });
  }
}
```

## 4. 文件存储方案

### 4.1 图片上传处理

#### 4.1.1 文件上传流程

```javascript
class FileUploader {
  async uploadFile(file, options = {}) {
    // 1. 文件验证
    await this.validateFile(file, options);
    
    // 2. 图片处理（压缩、格式转换）
    const processedFile = await this.processImage(file, options);
    
    // 3. 生成唯一文件名
    const fileName = this.generateFileName(file, options);
    
    // 4. 上传到存储服务
    const fileUrl = await this.uploadToStorage(processedFile, fileName);
    
    // 5. 保存文件记录到数据库
    const fileRecord = await File.create({
      fileName,
      originalName: file.name,
      fileSize: file.size,
      mimeType: file.type,
      url: fileUrl,
      uploaderId: options.uploaderId
    });
    
    return fileRecord;
  }
  
  async validateFile(file, options) {
    const maxSize = options.maxSize || 10 * 1024 * 1024; // 10MB
    const allowedTypes = options.allowedTypes || ['image/jpeg', 'image/png', 'image/gif'];
    
    if (file.size > maxSize) {
      throw new Error('文件大小超过限制');
    }
    
    if (!allowedTypes.includes(file.type)) {
      throw new Error('不支持的文件类型');
    }
  }
}
```

#### 4.1.2 图片处理优化

```javascript
class ImageProcessor {
  async processImage(file, options) {
    const image = await Jimp.read(file.buffer);
    
    // 自动旋转
    await image.autoOrient();
    
    // 调整大小
    if (options.maxWidth || options.maxHeight) {
      await image.scaleToFit(options.maxWidth || 800, options.maxHeight || 600);
    }
    
    // 质量压缩
    const quality = options.quality || 80;
    const processedBuffer = await image.getBufferAsync(file.type, { quality });
    
    return {
      ...file,
      buffer: processedBuffer,
      size: processedBuffer.length
    };
  }
}
```

### 4.2 文件分片上传

#### 4.2.1 大文件分片上传

```javascript
class ChunkedUploader {
  async uploadLargeFile(file, options = {}) {
    const chunkSize = options.chunkSize || 5 * 1024 * 1024; // 5MB
    const totalChunks = Math.ceil(file.size / chunkSize);
    const uploadId = generateUploadId();
    
    // 初始化上传
    await this.initUpload(uploadId, file, totalChunks);
    
    // 并行上传分片
    const uploadPromises = [];
    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
      const chunk = file.slice(chunkIndex * chunkSize, (chunkIndex + 1) * chunkSize);
      uploadPromises.push(this.uploadChunk(uploadId, chunkIndex, chunk));
    }
    
    await Promise.all(uploadPromises);
    
    // 完成上传
    return await this.completeUpload(uploadId);
  }
  
  async uploadChunk(uploadId, chunkIndex, chunk) {
    const formData = new FormData();
    formData.append('uploadId', uploadId);
    formData.append('chunkIndex', chunkIndex);
    formData.append('chunk', chunk);
    
    const response = await fetch('/api/files/upload-chunk', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`分片上传失败: ${chunkIndex}`);
    }
  }
}
```

### 4.3 存储策略配置

#### 4.3.1 多存储后端支持

```javascript
class StorageManager {
  constructor() {
    this.storages = {
      'local': new LocalStorage(),
      's3': new S3Storage(),
      'oss': new OSSStorage()
    };
    this.defaultStorage = 'local';
  }
  
  async upload(file, options = {}) {
    const storageType = options.storage || this.defaultStorage;
    const storage = this.storages[storageType];
    
    if (!storage) {
      throw new Error(`不支持的存储类型: ${storageType}`);
    }
    
    return await storage.upload(file, options);
  }
  
  async getUrl(fileId, options = {}) {
    const fileRecord = await File.findById(fileId);
    const storage = this.storages[fileRecord.storageType];
    
    return await storage.getUrl(fileRecord.filePath, options);
  }
}
```

### 4.4 CDN集成方案

#### 4.4.1 CDN配置管理

```javascript
class CDNManager {
  constructor() {
    this.cdnConfig = {
      domain: 'cdn.example.com',
      regions: ['us-east-1', 'eu-west-1', 'ap-southeast-1'],
      cacheTTL: 86400 // 24小时
    };
  }
  
  async purgeCache(fileUrls) {
    // 清除CDN缓存
    const purgeTasks = fileUrls.map(url => 
      this.cdnClient.purge(url)
    );
    
    await Promise.all(purgeTasks);
  }
  
  generateCDNUrl(filePath, options = {}) {
    const url = new URL(`https://${this.cdnConfig.domain}`);
    url.pathname = filePath;
    
    if (options.quality) {
      url.searchParams.set('q', options.quality);
    }
    
    if (options.format) {
      url.searchParams.set('f', options.format);
    }
    
    return url.toString();
  }
}
```

## 5. 监控告警系统

### 5.1 系统监控指标

#### 5.1.1 应用性能监控

```javascript
class APMMonitor {
  constructor() {
    this.metrics = {
      responseTime: new Histogram(),
      errorRate: new Counter(),
      throughput: new Meter(),
      memoryUsage: new Gauge()
    };
  }
  
  recordApiCall(method, path, duration, statusCode) {
    this.metrics.responseTime.record(duration);
    this.metrics.throughput.mark();
    
    if (statusCode >= 400) {
      this.metrics.errorRate.inc();
    }
    
    // 发送到监控系统
    this.sendMetrics({
      metric: 'api.response_time',
      tags: { method, path, status: statusCode },
      value: duration
    });
  }
}
```

#### 5.1.2 数据库监控

```javascript
class DatabaseMonitor {
  async collectMetrics() {
    const metrics = {
      connections: await this.getConnectionCount(),
      queryTime: await this.getQueryPerformance(),
      replicationLag: await this.getReplicationLag(),
      tableSizes: await this.getTableSizes()
    };
    
    this.sendToMonitoringSystem(metrics);
  }
  
  async getReplicationLag() {
    const result = await db.query('SHOW SLAVE STATUS');
    return result.Seconds_Behind_Master || 0;
  }
}
```

### 5.2 告警规则配置

#### 5.2.1 告警规则定义

```yaml
# 告警规则配置
alert_rules:
  - name: "高错误率告警"
    metric: "api.error_rate"
    condition: "rate > 0.05"  # 错误率超过5%
    duration: "5m"
    severity: "critical"
    
  - name: "响应时间异常"
    metric: "api.response_time.p95"
    condition: "value > 2000"  # P95响应时间超过2秒
    duration: "10m"
    severity: "warning"
    
  - name: "数据库连接池满"
    metric: "db.connections.active"
    condition: "value / max > 0.8"  # 连接使用率超过80%
    duration: "3m"
    severity: "critical"
```

#### 5.2.2 告警通知渠道

```javascript
class AlertManager {
  constructor() {
    this.notificationChannels = {
      'email': new EmailNotifier(),
      'sms': new SMSNotifier(),
      'slack': new SlackNotifier(),
      'webhook': new WebhookNotifier()
    };
  }
  
  async sendAlert(alert, channels = ['email', 'slack']) {
    const notificationTasks = channels.map(channel => {
      const notifier = this.notificationChannels[channel];
      if (notifier) {
        return notifier.send(alert);
      }
    });
    
    await Promise.all(notificationTasks.filter(task => task));
  }
}
```

## 6. 安全架构设计

### 6.1 数据加密方案

#### 6.1.1 敏感数据加密

```javascript
class DataEncryptor {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.key = process.env.ENCRYPTION_KEY;
  }
  
  async encryptSensitiveData(data) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key);
    
    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
      iv: iv.toString('hex'),
      data: encrypted,
      authTag: cipher.getAuthTag().toString('hex')
    };
  }
  
  async decryptSensitiveData(encryptedData) {
    const decipher = crypto.createDecipher(this.algorithm, this.key);
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}
```

### 6.2 API安全防护

#### 6.2.1 请求频率限制

```javascript
class RateLimiter {
  constructor() {
    this.limits = {
      'auth-login': { window: 3600, max: 5 },     // 1小时内最多5次登录尝试
      'api-generic': { window: 60, max: 60 },     // 1分钟内最多60次API调用
      'file-upload': { window: 300, max: 10 }     // 5分钟内最多10次文件上传
    };
  }
  
  async checkLimit(identifier, endpoint) {
    const limitConfig = this.limits[endpoint] || this.limits['api-generic'];
    const key = `rate_limit:${identifier}:${endpoint}`;
    
    const current = await redis.incr(key);
    if (current === 1) {
      await redis.expire(key, limitConfig.window);
    }
    
    if (current > limitConfig.max) {
      throw new Error('请求频率过高，请稍后重试');
    }
    
    return {
      remaining: Math.max(0, limitConfig.max - current),
      reset: await redis.ttl(key)
    };
  }
}
```

这个技术架构更新文档完整地覆盖了数据库优化、缓存层设计、消息队列、文件存储等关键技术实现细节，为系统的技术实现提供了全面的指导。